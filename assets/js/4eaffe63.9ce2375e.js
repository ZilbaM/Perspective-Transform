"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[821],{7932:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"editing-mode","title":"Editing Mode","description":"Toggling Edit Mode","source":"@site/docs/04-editing-mode.md","sourceDirName":".","slug":"/editing-mode","permalink":"/react-perspective-transform/editing-mode","draft":false,"unlisted":false,"editUrl":"https://github.com/ZilbaM/react-perspective-transform/edit/main/docs/docs/04-editing-mode.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Editing Mode","slug":"/editing-mode"},"sidebar":"docs","previous":{"title":"Controlled vs. Uncontrolled","permalink":"/react-perspective-transform/controlled-vs-uncontrolled"},"next":{"title":"Persistence","permalink":"/react-perspective-transform/persistence"}}');var o=t(4848),s=t(8453);const d={title:"Editing Mode",slug:"/editing-mode"},r="Editing Mode",l={},c=[{value:"Toggling Edit Mode",id:"toggling-edit-mode",level:2},{value:"Editable Prop (Controlled Edit Mode)",id:"editable-prop-controlled-edit-mode",level:2},{value:"Corner Control Points",id:"corner-control-points",level:2},{value:"Alignment Guides",id:"alignment-guides",level:3}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"editing-mode",children:"Editing Mode"})}),"\n",(0,o.jsx)(n.h2,{id:"toggling-edit-mode",children:"Toggling Edit Mode"}),"\n",(0,o.jsxs)(n.p,{children:["By default, you can press ",(0,o.jsx)(n.strong,{children:"Shift+P"})," to toggle edit mode. Corner handles appear, letting you drag each corner individually. You can customize this key by passing ",(0,o.jsx)(n.code,{children:"toggleKeys"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'<PerspectiveTransform toggleKeys={["r", "m"]}>\n  <img src="/photo.jpg" />\n</PerspectiveTransform>\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Now, ",(0,o.jsx)(n.strong,{children:"Shift+R"})," or ",(0,o.jsx)(n.strong,{children:"Shift+M"})," toggles edit mode."]}),"\n",(0,o.jsx)(n.h2,{id:"editable-prop-controlled-edit-mode",children:"Editable Prop (Controlled Edit Mode)"}),"\n",(0,o.jsxs)(n.p,{children:["If you want to handle edit mode from the parent, pass the ",(0,o.jsx)(n.code,{children:"editable"})," boolean:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'function ControlledEditMode() {\n  const [isEditable, setIsEditable] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setIsEditable(!isEditable)}>Toggle Edit</button>\n      <PerspectiveTransform\n        editable={isEditable}\n        onEditableChange={setIsEditable}\n      >\n        <img src="/photo.jpg" />\n      </PerspectiveTransform>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"onEditableChange"})," is called when Shift + ",(0,o.jsx)(n.code,{children:"[toggleKeys]"})," is pressed, letting the parent know to update its ",(0,o.jsx)(n.code,{children:"editable"})," state."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"corner-control-points",children:"Corner Control Points"}),"\n",(0,o.jsxs)(n.p,{children:["When edit mode is ",(0,o.jsx)(n.strong,{children:"on"}),", each corner has a draggable handle. The styles for ",(0,o.jsx)(n.code,{children:".control-point"})," are in ",(0,o.jsx)(n.code,{children:"style.css"}),". Customize these to change color, shape, or size."]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h3,{id:"alignment-guides",children:"Alignment Guides"}),"\n",(0,o.jsxs)(n.p,{children:["In edit mode, an overlay (",(0,o.jsx)(n.code,{children:".alignment-guides"}),") is rendered ",(0,o.jsx)(n.strong,{children:"inside"})," the transformed wrapper. This means the grid will warp with the content. You can style ",(0,o.jsx)(n.code,{children:".alignment-guides"})," for grid lines, bounding boxes, or other alignment visuals."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>r});var i=t(6540);const o={},s=i.createContext(o);function d(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);