"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[893],{2141:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>i});const t=JSON.parse('{"id":"controlled-vs-uncontrolled","title":"Controlled vs. Uncontrolled","description":"PerspectiveTransform can manage its own corner states (uncontrolled) or accept points and editable props from the parent (controlled). Below we explore both patterns:","source":"@site/docs/03-controlled-vs-uncontrolled.md","sourceDirName":".","slug":"/controlled-vs-uncontrolled","permalink":"/react-perspective-transform/controlled-vs-uncontrolled","draft":false,"unlisted":false,"editUrl":"https://github.com/ZilbaM/react-perspective-transform/edit/main/docs/docs/03-controlled-vs-uncontrolled.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Controlled vs. Uncontrolled","slug":"/controlled-vs-uncontrolled"},"sidebar":"docs","previous":{"title":"Getting Started","permalink":"/react-perspective-transform/getting-started"},"next":{"title":"Editing Mode","permalink":"/react-perspective-transform/editing-mode"}}');var r=o(4848),l=o(8453);const s={title:"Controlled vs. Uncontrolled",slug:"/controlled-vs-uncontrolled"},c="Controlled vs. Uncontrolled Mode",d={},i=[{value:"Uncontrolled Mode",id:"uncontrolled-mode",level:2},{value:"Controlled Mode",id:"controlled-mode",level:2},{value:"Key Differences",id:"key-differences",level:3},{value:"Changing Modes Dynamically",id:"changing-modes-dynamically",level:2}];function a(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"controlled-vs-uncontrolled-mode",children:"Controlled vs. Uncontrolled Mode"})}),"\n",(0,r.jsxs)(n.p,{children:["PerspectiveTransform can manage its own corner states (uncontrolled) or accept ",(0,r.jsx)(n.code,{children:"points"})," and ",(0,r.jsx)(n.code,{children:"editable"})," props from the parent (controlled). Below we explore both patterns:"]}),"\n",(0,r.jsx)(n.h2,{id:"uncontrolled-mode",children:"Uncontrolled Mode"}),"\n",(0,r.jsxs)(n.p,{children:["In ",(0,r.jsx)(n.strong,{children:"uncontrolled mode"}),", you do ",(0,r.jsx)(n.em,{children:"not"})," pass the ",(0,r.jsx)(n.code,{children:"points"})," prop. The component stores corner states internally. Optionally, you can provide a ",(0,r.jsx)(n.code,{children:"storageKey"})," for persistence:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'<PerspectiveTransform storageKey="uncontrolled-demo">\n  <img src="unicorn.png" alt="Unicorn" />\n</PerspectiveTransform>\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The user can drag corners and toggle edit mode using SHIFT + P."}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"storageKey"})," is set, changes are saved to ",(0,r.jsx)(n.code,{children:"localStorage"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"controlled-mode",children:"Controlled Mode"}),"\n",(0,r.jsxs)(n.p,{children:["In ",(0,r.jsx)(n.strong,{children:"controlled mode"}),", you pass a ",(0,r.jsx)(n.code,{children:"points"})," object and manage corner states in your own application. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"function ControlledExample() {\n  const [points, setPoints] = useState<Points>({\n    topLeft: { x: 50, y: 50 },\n    topRight: { x: 250, y: 50 },\n    bottomRight: { x: 250, y: 200 },\n    bottomLeft: { x: 50, y: 200 },\n  });\n  const [editable, setEditable] = useState(false);\n\n  return (\n    <PerspectiveTransform\n      points={points}\n      onPointsChange={setPoints}\n      editable={editable}\n      onEditableChange={setEditable}\n    >\n      <div style={{ width: 300, height: 150, background: 'blue' }} />\n    </PerspectiveTransform>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"key-differences",children:"Key Differences"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Uncontrolled"}),": The component is simpler to set up, and can optionally persist data in localStorage."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Controlled"}),": You have full control over ",(0,r.jsx)(n.code,{children:"points"})," and ",(0,r.jsx)(n.code,{children:"editable"}),". Perfect if you want to sync with Redux, a server, or your own state management."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"changing-modes-dynamically",children:"Changing Modes Dynamically"}),"\n",(0,r.jsxs)(n.p,{children:["You generally want to pick one approach per instance. If you provide ",(0,r.jsx)(n.code,{children:"points"}),", the component treats them as the source of truth. If you omit ",(0,r.jsx)(n.code,{children:"points"}),", it manages them internally."]})]})}function p(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>c});var t=o(6540);const r={},l=t.createContext(r);function s(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);